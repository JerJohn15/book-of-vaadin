<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="themes">
	<title>Themes</title>

    <indexterm xml:id="term.themes" class="startofrange">
        <primary>theme</primary>
    </indexterm>
    <indexterm xml:id="term.themes-css" class="startofrange">
        <primary>CSS</primary>
    </indexterm>

	<para>
		This chapter provides details about using and creating <emphasis>themes</emphasis>
		that control the visual look of web applications. Themes are created using Sass,
		which is an extension of CSS (Cascading Style Sheets), or with plain CSS. We
		provide an introduction to CSS, especially concerning the styling of HTML by
		element classes.
	</para>

	<section xml:id="themes.overview">
		<title>Overview</title>

		<para>
			Vaadin separates the appearance of the user interface from its logic using
			<emphasis>themes</emphasis>. Themes can include Sass or CSS style sheets, custom HTML
			layouts, and any necessary graphics. Theme resources can also be accessed from
			application code as <classname>ThemeResource</classname> objects.
		</para>

		<para>
			Custom themes are placed under the <filename>VAADIN/themes/</filename> folder
			of the web application (under <filename>WebContent</filename> in Eclipse or
			<filename>src/main/webapp</filename> in Maven projects).  This location is
			fixed -- the <filename>VAADIN</filename> folder contains static resources that
			are served by the Vaadin servlet. The servlet augments the files stored in the
			folder by resources found from corresponding <filename>VAADIN</filename>
			folders contained in JARs in the class path. For example, the built-in themes
			are stored in the <filename>vaadin-themes.jar</filename>.
        </para>

        <para>
            <xref linkend="figure.themes.theme-contents"/> illustrates the contents of a
            theme.
		</para>

		<figure xml:id="figure.themes.theme-contents">
			<title>Contents of a Theme</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/themes/theme-contents-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="60" smallscale="100%" align="center" fileref="img/themes/theme-contents-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The name of a theme folder defines the name of the theme. The name is used in
			the <literal>@Theme</literal> annotation that sets the theme. A theme must
			contain either a <filename>styles.scss</filename> for Sass themes, or
			<filename>styles.css</filename> stylesheet for plain CSS themes, but other
			contents have free naming. We recommend that you have the actual theme content
			in a SCSS file named after the theme, such as
			<filename>mytheme.scss</filename>, to make the names more unique.
		</para>

        <para>
            We also suggest a convention for naming the folders as
            <filename>img</filename> for images, <filename>layouts</filename> for custom
            layouts, and <filename>css</filename> for additional stylesheets.
        </para>

		<para>
			Custom themes need to extend a base theme, as described in <xref
			linkend="themes.creating"/>. Copying and modifying an existing theme is also
			possible, but it is not recommended, as it may need more work to maintain if
			the modifications are small.
		</para>

		<para>
			You use a theme by specifying it with the <literal>@Theme</literal>
			annotation for the &ui; class of the application as follows:
		</para>

		<programlisting><![CDATA[@Theme("mytheme")
public class MyUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        ...
    }
}]]></programlisting>

		<para>
			A theme can contain alternate styles for user interface components, which can
			be changed as needed.
		</para>

		<para>
			In addition to style sheets, a theme can contain HTML templates for custom
			layouts used with <classname>CustomLayout</classname>. See <xref
			linkend="layout.customlayout"/> for details.
		</para>

		<para>
			Resources provided in a theme can also be accessed using the
			<classname>ThemeResource</classname> class, as described in <xref
			linkend="application.resources.theme"/>. This allows displaying theme
			resources in component icons, in the <classname>Image</classname> component,
			and other such uses.
		</para>
	</section>

	<section xml:id="themes.css">
		<title>Introduction to Cascading Style Sheets</title>
		
        <indexterm xml:id="term.themes.css" class="startofrange">
            <primary>CSS</primary>
            <secondary>introduction</secondary>
        </indexterm>

		<para>
			Cascading Style Sheets or CSS is the basic technique to separate the
			appearance of a web page from the content represented in HTML. In this
			section, we give an introduction to CSS and look how they are relevant to
			software development with Vaadin.
        </para>

        <simplesect xml:id="themes.css.sources">
            <title>CSS Information Sources</title>

            <para>
                As we can only give a short intruction in this book, we encourage you to
                refer to the rich literature on CSS and the many resources available in
                the web. You can find the authoratitative specifications of CSS standards
                from the <link xlink:href="http://www.w3.org/Style/CSS/">W3C
                website</link><phrase condition="web">and other literature, references,
                and tutorials from the <link
                xlink:href="http://www.dmoz.org/Computers/Data_Formats/Style_Sheets/CSS/">Open
                Directory Project page on CSS</link>, as well as from other
                sources</phrase>.
            </para>
        </simplesect>

        <section xml:id="themes.css.basics">
			<title>Applying CSS to HTML</title>

            <para>
                Let us consider the following HTML document that contains various markup
                elements for formatting text. Vaadin UIs work in essentially similar
                documents, even though they use somewhat different elements to draw the
                user interface.
            </para>

			<programlisting>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My Page&lt;/title&gt;
        &lt;link rel="stylesheet" type="text/css"
              href="mystylesheet.css"/&gt;
    &lt;/head&gt;
    &lt;body&gt;
        <emphasis role="strong">&lt;p&gt;</emphasis>This is a paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>
        <emphasis role="strong">&lt;p&gt;</emphasis>This is another paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>
        &lt;table&gt;
            &lt;tr&gt;
                <emphasis role="strong">&lt;td&gt;</emphasis>This is a table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
                <emphasis role="strong">&lt;td&gt;</emphasis>This is another table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

            <para>
                The HTML elements that will be styled later by matching CSS rules are
                emphasized above.
            </para>

            <para>
                The <literal>&lt;link&gt;</literal> element in the HTML header defines the
                used CSS stylesheet. The definition is automatically generated by Vaadin
                in the HTML page that loads the UI of the application. A stylesheet can
                also be embedded in the HTML document itself, as is done when optimizing
                their loading in Vaadin TouchKit, for example.
            </para>
        </section>

        <section xml:id="themes.css.basics">
			<title>Basic CSS Rules</title>

			<para>
				A stylesheet contains a set of <emphasis>rules</emphasis> that can match
				the HTML elements in the page. Each rule consists of one or more
				<emphasis>selectors</emphasis>, separated with commas, and a
				<emphasis>declaration block</emphasis> enclosed in curly braces. A
				declaration block contains a list of <emphasis>property</emphasis>
				statements. Each property has a label and a value, separated with a
				colon. A property statement ends with a semicolon.
			</para>

			<para>
				Let us look at an example that matches certain elements in the simple HTML
				document given in the previous section:
			</para>

			<programlisting><![CDATA[p, td { 
  color: blue;
}

td { 
  background: yellow;
  font-weight: bold;
}]]></programlisting>

			<para>
				The <literal>p</literal> and <literal>td</literal> are element type
				selectors that match with <literal>&lt;p&gt;</literal> and
				<literal>&lt;td&gt;</literal> elements in HTML, respectively. The first
				rule matches with both elements, while the second matches only with
				<literal>&lt;td&gt;</literal> elements. Let us assume that you have saved
				the above style sheet with the name <filename>mystylesheet.css</filename>
				and consider the following HTML file located in the same folder.
			</para>

			<figure xml:id="figure.themes.basic.1">
				<title>Simple Styling by Element Type</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/themes/themes-css-match-1.png"/>
					</imageobject>
				</mediaobject>
			</figure>
				
            <section xml:id="themes.css.basics.inheritance">
                <title>Style Inheritance in CSS</title>

                <para>
                    CSS has <emphasis>inheritance</emphasis> where contained elements
                    inherit the properties of their parent elements. For example, let us
                    change the above example and define it instead as follows:
                </para>

                <programlisting><![CDATA[table {
    color: blue;
    background: yellow;
}]]></programlisting>

                <para>
                    All elements contained in the <literal>&lt;table&gt;</literal> element
                    would have the same properties. For example, the text in the contained
                    <literal>&lt;td&gt;</literal> elements would be in blue color.
                </para>
            </section>

            <section xml:id="themes.css.basics.element-types">
                <title>HTML Element Types</title>

                <para>
                    HTML has a number of element types, each of which accepts a specific
                    set of properties. The <literal>&lt;div&gt;</literal> elements are
                    generic elements that can be used to create almost any layout and
                    formatting that can be created with a specific HTML element
                    type. Vaadin uses <literal>&lt;div&gt;</literal> elements extensively
                    to draw the UI, especially in layout components.
                </para>

                <para>
                    <indexterm><primary>Google Web Toolkit</primary><secondary>themeing</secondary></indexterm>

                    Matching elements by their type as shown above is, however, rarely if
                    ever used in style sheets for Vaadin applications. We used it above,
                    because it is the normal way in regular HTML documents that use the
                    various HTML elements for formatting text, but it is not applicable in
                    Vaadin UIs that consist mostly of <literal>&lt;div&gt;</literal>
                    elements. Instead, you need to match by element class, as described
                    next.
                </para>
            </section>
		</section>

        <section xml:id="themes.css.matching-by-class">
			<title>Matching by Element Class</title>

			<para>
				Matching HTML elements by the <emphasis>class</emphasis> attribute is the
				most common form of matching in Vaadin stylesheets. It is also possible to
				match with the <emphasis>identifier</emphasis> of a unique HTML element.
			</para>

			<para>
				The class of an HTML element is defined with the
				<parameter>class</parameter> attribute as follows:
			</para>

<programlisting><?pocket-size 70% ?>&lt;html&gt;
  &lt;body&gt;
    <emphasis role="strong">&lt;p class="normal"&gt;</emphasis>This is the first paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>

    <emphasis role="strong">&lt;p class="another"&gt;</emphasis>This is the second paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>

    &lt;table&gt;
      &lt;tr&gt;
        <emphasis role="strong">&lt;td class="normal"&gt;</emphasis>This is a table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
        <emphasis role="strong">&lt;td class="another"&gt;</emphasis>This is another table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>

			<para>
				The class attributes of HTML elements can be matched in CSS rules with a
				selector notation where the class name is written after a period following
				the element name. This gives us full control of matching elements by their
				type and class.
			</para>

			<programlisting><![CDATA[p.normal   {color: red;}
p.another  {color: blue;}
td.normal  {background: pink;}
td.another {background: yellow;}]]></programlisting>

			<para>
				The page would look as shown below:
			</para>

			<figure>
				<title>Matching HTML Element Type and Class</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/themes/themes-css-match-class-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" smallscale="100%" align="center" fileref="img/themes/themes-css-match-class-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				We can also match solely by the class by using the universal selector
				<literal>*</literal> for the element name, for example
				<literal>*.normal</literal>. The universal selector can also be left out
				altogether so that we use just the class name following the period, for
				example <literal>.normal</literal>.
			</para>

			<programlisting><![CDATA[.normal {
    color: red;
}

.another {
    blackground: yellow;
}]]></programlisting>

			<para>
				In this case, the rule will match with all elements of the same class
				regardless of the element type. The result is shown in <xref
				linkend="figure.themes.match.class"/>.  This example illustrates a
				technique to make style sheets compatible regardless of the exact HTML
				element used in drawing a component.
			</para>

			<figure xml:id="figure.themes.match.class">
				<title>Matching Only HTML Element Class</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/themes/themes-css-match-class-3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="65" smallscale="100%" align="center" fileref="img/themes/themes-css-match-class-3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				To ensure future compatibility, we recommend that you use only matching
				based on the classes and <emphasis>do not</emphasis> match for specific
				HTML element types in CSS rules, because Vaadin may change the exact HTML
				implementation how components are drawn in the future. For example, Vaadin
				earlier used <literal>&lt;div&gt;</literal> element to draw
				<classname>Button</classname> components, but later it was changed to use
				the special-purpose <literal>&lt;button&gt;</literal> element in
				HTML. Because of using the <literal>v-button</literal> style class in the
				CSS rules for the button, styling it has changed only very little.
			</para>
		</section>

        <section xml:id="themes.css.matching-by-descendants">
			<title>Matching by Descendant Relationship</title>

			<para>
				CSS allows matching HTML by their containment relationship. For example,
				consider the following HTML fragment:
			</para>

			<programlisting><?pocket-size 70% ?>&lt;body&gt;
  &lt;p class="mytext"&gt;Here is some text inside a
                    paragraph element&lt;/p&gt;
  &lt;table class="<emphasis role="strong">mytable</emphasis>"&gt;
    &lt;tr&gt;
      &lt;td class="<emphasis role="strong">mytext</emphasis>"&gt;Here is text inside
                      a table and inside a td element.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/body&gt;</programlisting>

			<para>
				Matching by the class name <literal>.mytext</literal> alone would match
				both the <literal>&lt;p&gt;</literal> and <literal>&lt;td&gt;</literal>
				elements. If we want to match only the table cell, we could use the following selector:
			</para>

			<programlisting><![CDATA[.mytable .mytext {color: blue;}]]></programlisting>

			<para>
				To match, a class listed in a rule does not have to be an immediate
				descendant of the previous class, but just a descendant. For example, the
				selector "<literal>.v-panel .v-button</literal>" would match all elements
				with class <literal>.v-button</literal> somewhere inside an element with
				class <literal>.v-panel</literal>.
			</para>
        </section>

        <section xml:id="themes.css.cascading">
            <title>Importance of Cascading</title>

            <para>
                CSS or Cascading Stylesheets are, as the name implies, about
                <emphasis>cascading</emphasis> stylesheets, which means applying the
                stylesheet rules according to their origin, importance, scope, specifity,
                and order.
            </para>

            <para>
                For exact rules for cascading in CSS, see the section <link
                xlink:href="http://www.w3.org/TR/css3-cascade/#cascading">Cascading</link>
                in the CSS specification.
            </para>

            <section xml:id="themes.css.cascading.importance">
                <title>Importance</title>

                <para>
                    Declarations in CSS rules can be made override declarations with
                    otherwise higher priority by annotating them as
                    <literal>!important</literal>. For example, an inline style setting
                    made in the <literal>style</literal> attribute of an HTML element has
                    a higher specificity than any rule in a CSS stylesheet.
                </para>

                <programlisting><![CDATA[<div class="v-button" style="height: 20px;">...]]></programlisting>

                <para>
                    You can override the higher specificity with the
                    <literal>!important</literal> annotation as follows:
                </para>

                <programlisting><![CDATA[.v-button {height: 30px !important;}]]></programlisting>
            </section>

            <section xml:id="themes.css.cascading.specificity">
                <title>Specificity</title>

                <para>
                    A rule that specifies an element with selectors more closely overrides
                    ones that specify it less specifically. With respect to the element
                    class selectors most commonly used in Vaadin themes, the specificity
                    is determined by the number of class selectors in the selector.
                </para>

                <programlisting><![CDATA[.v-button {}
.v-verticallayout .v-button {}
.v-app .v-verticallayout .v-button {}]]></programlisting>

                <para>
                    In the above example, the last rule would have the highest specificity
                    and would match.
                </para>

                <para>
                    As noted earlier, style declarations given in the style attribute of a
                    HTML element have higher specificity than declarations in a CSS rule,
                    except if the <literal>!important</literal> annotation is given.
                </para>

                <para>
                    See the CSS3 <link
                    xlink:href="http://www.w3.org/TR/selectors/#specificity">selectors
                    module specification</link> for details regarding how the specificity
                    is computed.
                </para>
            </section>

            <section xml:id="themes.css.cascading.order">
                <title>Order</title>

                <para>
                    CSS rules given later have higher priority than ones given
                    earlier. For example, in the following, the latter rule overrides the
                    former and the color will be black:
                </para>

                <programlisting><![CDATA[.v-button {color: white}
.v-button {color: black}]]></programlisting>

                <para>
                    As specificity has a higher cascading priority than order, you could
                    make the first rule have higher priority by adding specificity as
                    follows:
                </para>

                <programlisting><![CDATA[.v-app .v-button {color: white}
.v-button {color: black}]]></programlisting>

                <para>
                    The order is important to notice in certain cases, because Vaadin does
                    not guarantee the order in which CSS stylesheets are loaded in the
                    browser, which can in fact be random and result in very unexpected
                    behavior. This is not relevant for Sass stylesheets, which are
                    compiled to a single stylesheet. For plain CSS stylesheets, such as
                    add-on or TouchKit stylesheets, the order can be relevant.
                </para>
            </section>
        </section>

        <section xml:id="themes.css.hierarchy">
            <title>Style Class Hierarchy of a Vaadin UI</title>

            <para>
                Let us give a real case in a Vaadin UI by considering a simple Vaadin UI
                with a label and a button inside a vertical layout:
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// UI has v-ui style class
@Theme("mytheme")
public class HelloWorld extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // VerticalLayout has v-verticallayout style
        VerticalLayout content = new VerticalLayout();
        setContent(content);

        // Label has v-label style
        content.addComponent(new Label("Hello World!"));
        
        // Button has v-button style
        content.addComponent(new Button("Push Me!",
            new Button.ClickListener() {
            @Override
            public void buttonClick(ClickEvent event) {
                Notification.show("Pushed!");
            }
        }));
    }
}]]></programlisting>

            <para>
                The UI will look by default as shown in <xref
                linkend="figure.themes.css.hierarchy.initial"/>. By using a HTML inspector
                such as Firebug, you can view the HTML tree and the element classes and
                applied styles for each element.
            </para>

            <figure xml:id="figure.themes.css.hierarchy.initial">
                <title>An Unthemed Vaadin UI</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/themes/example-ui-default.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Now, let us look at the HTML element class structure of the UI, as we can
                see it in the HTML inspector:
            </para>

            <programlisting><?pocket-size 65% ?>&lt;body class="<emphasis role="strong">v-generated-body v-ff v-ff20 v-ff200 v-gecko v-lin</emphasis>"
      scroll="auto"&gt;
  &lt;div id="bookexamplesvaadin7helloworld-447164942"
       class="<emphasis role="strong">v-app mytheme</emphasis>"&gt;
    &lt;div class="<emphasis role="strong">v-ui v-scrollable</emphasis>"
         tabindex="1" style="height: 100%; width: 100%;"&gt;
      &lt;div class="<emphasis role="strong">v-loading-indicator first</emphasis>"
           style="position: absolute; display: none;"&gt;&lt;/div&gt;
      &lt;div class="<emphasis role="strong">v-verticallayout v-layout v-vertical
                  v-widget v-has-width</emphasis>"
           style="width: 100%;"&gt;
        &lt;div class="<emphasis role="strong">v-slot</emphasis>"&gt;
          &lt;div class="<emphasis role="strong">v-label v-widget v-has-width</emphasis>"
               style="width: 100%;"&gt;Hello World!&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="<emphasis role="strong">v-slot</emphasis>"&gt;
          &lt;div class="<emphasis role="strong">v-button v-widget</emphasis>"
               tabindex="0" role="button"&gt;
            &lt;span class="<emphasis role="strong">v-button-wrap</emphasis>"&gt;
              &lt;span class="<emphasis role="strong">v-button-caption</emphasis>"&gt;Push Me!&lt;/span&gt;
            &lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  ...
&lt;body&gt;</programlisting>

            <para>
                Now, consider the following theme where we set the colors and margins of
                various elements. The theme is actually a Sass theme.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[@import "../reindeer/reindeer.scss";

@mixin mytheme {
  @include reindeer;

  /* White background for the entire UI */
  .v-ui {
    background: white;
  }
  
  /* All labels have white text on black background */
  .v-label {
    background: black;
    color: white;
    font-size: 24pt;
    line-height: 24pt;
    padding: 5px;
  }

  /* All buttons have blue caption and some margin */
  .v-button {
    margin: 10px;

    /* A nested selector to increase specificity */
    .v-button-caption {
      color: blue;
    }
  }
}]]></programlisting>

            <para>
                The look has changed as shown in <xref
                linkend="figure.themes.css.hierarchy.themed"/>.
            </para>
                
            <figure xml:id="figure.themes.css.hierarchy.themed">
                <title>Themed Vaadin UI</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/themes/example-ui-themed.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                An element can have multiple classes separated with a space. With multiple
                classes, a CSS rule matches an element if any of the classes match. This
                feature is used in many Vaadin components to allow matching based on the
                state of the component. For example, when the mouse is over a
                <classname>Link</classname> component, <literal>over</literal> class is
                added to the component. Most of such styling is a feature of Google Web
                Toolkit.
            </para>
        </section>
			
        <section xml:id="themes.css.compatibility">
			<title>Notes on Compatibility</title>

            <indexterm><primary>CSS</primary><secondary>compatibility</secondary></indexterm>
            <indexterm><primary>compatibility</primary></indexterm>

			<para>
				CSS is a standard continuously under development. It was first proposed in
				1994. The specification of CSS is maintained by the CSS Working Group of
				World Wide Web Consortium (W3C). Versioned with backward-compatible
				"levels", CSS Level 1 was published in 1996, Level 2 in 1998, and the
				ongoing development of CSS Level 3 started in 1998. CSS3 is divided into a
				number of separate modules, each developed and progressing separately, and
				many of the modules are already Level 4.
			</para>

			<para>
				While the support for CSS has been universal in all graphical web browsers
				since at least 1995, the support has been very incomplete at times and
				there still exists an unfortunate number of incompatibilities between
				browsers. While we have tried to take these incompatibilities into account
				in the built-in themes in Vaadin, you need to consider them while
				developing your own themes. Compatibility issues are detailed in various
				CSS handbooks.
			</para>
		</section>
		
        <indexterm startref="term.themes.css" class="endofrange"/>
	</section>
	
	<section xml:id="themes.sass">
		<title>Syntactically Awesome Stylesheets (Sass)</title>

        <para>
            Vaadin uses Sass for stylesheets. Sass is an extension of CSS3 that adds
            nested rules, variables, mixins, selector inheritance, and other features to
            CSS. Sass supports two formats for stylesheet: Vaadin themes are written in
            SCSS (<filename>.scss</filename>), which is a superset of CSS3, but Sass also
            allows a more concise indented format (<filename>.sass</filename>).
        </para>

        <para>
            Sass can be used in two basic ways in Vaadin applications, either by compiling
            SCSS files to CSS or by doing the compilation on the fly. The latter way is
            possible if the development mode is enabled for the Vaadin servlet, as
            described in <xref linkend="application.environment.parameters"/>.
        </para>

        <section xml:id="themes.sass.overview">
            <title>Sass Overview</title>

            <section xml:id="themes.sass.overview.variables">
                <title>Variables</title>

                <para>
                    Sass allows defining variables that can be used in the rules.
                </para>

                <programlisting><![CDATA[$textcolor: blue;

.v-button-caption {
  color: $textcolor;
}]]></programlisting>

                <para>
                    The above rule would be compiled to CSS as:
                </para>

                <programlisting><![CDATA[.v-button-caption {
  color: blue;
}]]></programlisting>

                <para>
                    Also mixins can have variables as parameters, as explained later.
                </para>
            </section>

            <section xml:id="themes.sass.overview.nesting">
                <title>Nesting</title>

                <para>
                    Sass supports nested rules, which are compiled into
                    inside-selectors. For example:
                </para>

                <programlisting><![CDATA[.v-app {
  background: yellow;
  
  .mybutton {
    font-style: italic;
    
    .v-button-caption {
      color: blue;
    }
  }
}]]></programlisting>

                <para>
                    is compiled as:
                </para>

                <programlisting><![CDATA[.v-app {
  background: yellow;
}

.v-app .mybutton {
    font-style: italic;
}

.v-app .mybutton .v-button-caption {
  color: blue;
}]]></programlisting>

            </section>

            <section xml:id="themes.sass.overview.mixins">
                <title>Mixins</title>

                <para>
                    Mixins are rules that can be included in other rules. You define a
                    mixin rule by prefixing it with the <literal>@mixin</literal> keyword
                    and the name of the mixin. You can then use
                    <literal>@include</literal> to apply it to another rule. You can also
                    pass parameters to it, which are handled as local variables in the
                    mixin.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><![CDATA[@mixin mymixin {
  background: yellow;
}

@mixin othermixin($param) {
  margin: $param;
}

.v-button-caption {
  @include mymixin;
  @include othermixin(10px);
}]]></programlisting>

                <para>
                    The above SCSS would translated to the following CSS:
                </para>

                <programlisting><![CDATA[.v-button-caption {
  background: yellow;
  margin: 10px;
}]]></programlisting>

                <para>
                    You can also have nested rules in a mixin, which makes them especially
                    powerful. Mixing in rules is used when extending Vaadin themes, as
                    described in <xref linkend="themes.creating.sass"/>.
                </para>

                <para>
                    Vaadin themes are defined as mixins to allow for certain uses, such as
                    different themes for different portlets in a portal.
                </para>
            </section>

            <!-- TODO 
            <section xml:id="themes.sass.features">
                <title>Selector Inheritance</title>

            </section>
            -->
        </section>

        <section xml:id="themes.sass.basic">
            <title>Sass Basics with Vaadin</title>

            <para>
                We are not going to give in-depth documentation of Sass and refer you to
                its excellent documentation at <link
                xlink:href="http://sass-lang.com/">http://sass-lang.com/</link>. In the
                following, we give just basic introduction to using it with Vaadin.
            </para>

            <para>
                You can create a new Sass-based theme with the Eclipse plugin, as
                described in <xref linkend="themes.eclipse"/>.
            </para>
        </section>

        <section xml:id="themes.sass.compiling">
            <title>Compiling Sass Themes</title>

            <section xml:id="themes.sass.compiling.on-the-fly">
                <title>Compiling On the Fly</title>

                <para>
                    The easiest way to use Sass themes is to let the Vaadin servlet
                    compile them on the run. In this case, the SCSS source files are
                    placed in the theme folder. Compilation is done each time the
                    <filename>styles.css</filename> is requested from the server.
                </para>

                <para>
                    The on-the-fly compilation takes a bit time, so it is only available
                    when the Vaadin servlet is in the development mode, as described in
                    <xref linkend="application.environment.parameters"/>. Also, it
                    requires the theme compiler and all its dependencies to be in the
                    class path of the servlet. For production, you should compile the
                    theme to CSS, as described next.
                </para>
            </section>

            <section xml:id="themes.sass.compiling.eclipse">
                <title>Compiling in Eclipse</title>

                <para>
                    If using Eclipse and the Vaadin Plugin for Eclipse, its project wizard
                    creates a Sass theme. It includes <menuchoice><guimenuitem>Compile
                    Theme</guimenuitem></menuchoice> command in the toolbar to compile the
                    project theme to CSS. Another command compiles also the widget set.
                </para>

                <figure xml:id="figure.themes.sass.compiling-eclipse">
                    <title>Compiling Sass Theme</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/themes/eclipse-theme-compiler.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    The <filename>WebContent/VAADIN/mytheme/styles.scss</filename> and any
                    Sass sources included by it are compiled to
                    <filename>styles.css</filename>.
                </para>
            </section>

            <section xml:id="themes.sass.compiling.maven">
                <title>Compiling with Maven</title>

                <para>
                    To compile the themes with Maven, you need to include the built-in
                    themes as a dependency:
                </para>

                <programlisting><![CDATA[  ...
  <dependencies>
    ...
    <dependency>
        <groupId>com.vaadin</groupId>
        <artifactId>vaadin-themes</artifactId>
        <version>${vaadin.version}</version>
    </dependency>
  </dependencies>
  ...]]></programlisting>

                <para>
                    This is automatically included at least in the
                    <literal>vaadin-archetype-application</literal> archetype for Vaadin
                    applications. The actual theme compilation is most conveniently done
                    by the Vaadin Maven Plugin with <literal>update-theme</literal> and
                    <literal>compile-theme</literal> goals.
                </para>

                <programlisting><![CDATA[  ...
  <plugin>
    <groupId>com.vaadin</groupId>
    <artifactId>vaadin-maven-plugin</artifactId>
    ...
    <executions>
      <execution>
        ...
        <goals>
          <goal>clean</goal>
          <goal>resources</goal>
          <goal>update-theme</goal>
          <goal>update-widgetset</goal>
          <goal>compile-theme</goal>
          <goal>compile</goal>
        </goals>
      </execution>
    </executions>]]></programlisting>

                <para>
                    Once these are in place, the theme is compiled as part of relevant
                    lifecycle phases, such as <literal>package</literal>.
                </para>

                <screen><command>mvn</command> <parameter>package</parameter></screen>

                <para>
                    You can also compile just the theme with the
                    <package>compile-theme</package> goal:
                </para>

                <screen><command>mvn</command> <parameter>vaadin:compile-theme</parameter></screen>

            </section>

            <section xml:id="themes.sass.compiling.command-line" condition="web">
                <title>Compiling in Command-line</title>

                <para>
                    Sass style sheets can be compiled to CSS, with the
                    <filename>styles.css</filename> of a custom theme as the compilation
                    target. When compiled before deployment, the source files do not need to
                    be in the theme folder.
                </para>

                <screen><command>java</command> <parameter>-cp</parameter> <replaceable>'../../../WEB-INF/lib/*'</replaceable> com.vaadin.sass.SassCompiler styles.scss styles.css</screen>

                <para>
                    The <parameter>-cp</parameter> parameter should point to the class
                    path where the Vaadin JARs are located. In the above example, they are
                    assumed to be locate in the <filename>WEB-INF/lib</filename> folder of
                    the web application. If you have loaded the Vaadin libraries using
                    Ivy, as is the case with projects created with the Vaadin Plugin for
                    Eclipse, the Vaadin libraries are stored in Ivy's local
                    repository. Its folder hierarchy is somewhat scattered, so we
                    recommend that you retrieve the libraries to a single folder. We
                    recommend using an Ant script as is described next.
                </para>
            </section>

            <section xml:id="themes.sass.compiling.ant" condition="web">
                <title>Compiling with Ant</title>

                <para>
                    With Apache Ant, you can easily resolve the dependencies with Ivy and
                    compile the theme with the Theme Compiler included in Vaadin as
                    follows. This build step can be conveniently included in a WAR build
                    script.
                </para>

                <para>
                    Start with the following configuration:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[<project xmlns:ivy="antlib:org.apache.ivy.ant"
         name="My Project" basedir="../"
         default="package-war">

  <target name="configure">
    <!-- Where project source files are located -->
    <property name="src-location" value="src" />

    ... other project build definitions ...
            
    <!-- Name of the theme -->
    <property name="theme" value="book-examples"/>
        
    <!-- Compilation result directory -->
    <property name="result" value="build/result"/>
  </target>

  <!-- Initialize build -->
  <target name="init" depends="configure">
    <!-- Construct and check classpath -->
    <path id="compile.classpath">
        <!-- Source code to be compiled -->
        <pathelement path="${src-location}" />
            
        <!-- Vaadin libraries and dependencies -->
        <fileset dir="${result}/lib">
            <include name="*.jar"/>
        </fileset>
    </path>

    <mkdir dir="${result}"/>
  </target>]]></programlisting>

                <para>
                    You should first resolve all Vaadin libraries to a single directory,
                    which you can use for deployment, but also for theme compilation.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[  <target name="resolve" depends="init">
    <ivy:retrieve
        pattern="${result}/lib/[module]-[type]-[artifact]-[revision].[ext]"/>
  </target>]]></programlisting>

                <para>
                    Then, you can compile the theme as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[  <!-- Compile theme -->
  <target name="compile-theme"
          depends="init, resolve">
    <delete dir="${result}/VAADIN/themes/${theme}"/>
    <mkdir dir="${result}/VAADIN/themes/${theme}"/>
    	
    <java classname="com.vaadin.sass.SassCompiler"
          fork="true">
      <classpath>
        <path refid="compile.classpath"/>
      </classpath>
      <arg value="WebContent/VAADIN/themes/${theme}/styles.scss"/>
      <arg value="${result}/VAADIN/themes/${theme}/styles.css"/>
    </java>

    	<!-- Copy theme resources -->
    <copy todir="${result}/VAADIN/themes/${theme}">
      <fileset dir="WebContent/VAADIN/themes/${theme}">
        <exclude name="**/*.scss"/>
      </fileset>
    </copy>
  </target>
</project>]]></programlisting>

            </section>
        </section>
    </section>

	<section xml:id="themes.creating">
		<title>Creating and Using Themes</title>

        <para>
            Custom themes are placed in the <filename>VAADIN/themes</filename> folder of
            the web application, in an Eclipse project under the
            <filename>WebContent</filename> folder or <filename>src/main/webapp</filename>
            in Maven projects, as was illustrated in <xref
            linkend="figure.themes.theme-contents"/>. This location is fixed. You need to
            have a theme folder for each theme you use in your application, although
            applications rarely need more than a single theme.
        </para>

        <section xml:id="themes.creating.sass">
            <title>Sass Themes</title>

            <para>
                You can use Sass themes in Vaadin in two ways, either by compiling them to
                CSS by yourself or by letting the Vaadin servlet compile them for you
                on-the-fly when the theme CSS is requested by the browser, as described in
                <xref linkend="themes.sass.compiling"/>.
            </para>

            <para>
                To define a Sass theme with the name <varname>mytheme</varname>, you must
                place a file with name <filename>styles.scss</filename> in the theme
                folder <filename>VAADIN/themes/mytheme</filename>. If no
                <filename>styles.css</filename> exists in the folder, the Sass file is
                compiled on-the-fly when the theme is requested by a browser.
            </para>

            <para>
                We recommend that you organize the theme in at least two SCSS files so
                that you import the actual theme from a Sass file that is named more
                uniquely than the <filename>styles.scss</filename>, to make it
                distinquishable in the editor. This organization is how the Vaadin Plugin
                for Eclipse creates a new theme.
            </para>

            <para>
                If you use Vaadin add-ons that contain themes, Vaadin Plugin for Eclipse
                and Maven automatically add them to the <filename>addons.scss</filename>
                file.
            </para>

            <section xml:id="themes.creating.sass.scss">
                <title>Theme SCSS</title>

                <para>
                    We recommend that the rules in a theme should be prefixed with a
                    selector for the theme name. You can do the prefixing in Sass by
                    enclosing the rules in a nested rule with a selector for the theme
                    name.
                </para>

                <para>
                    Themes are defined as Sass mixins, so after you import the mixin
                    definitions, you can <literal>@include</literal> them in the theme rule as
                    follows:
                </para>

                <programlisting><![CDATA[@import "addons.scss";
@import "mytheme.scss";

.mytheme {
  @include addons;
  @include mytheme;
}]]></programlisting>

                <para>
                    However, this is mainly necessary if you use the UI in portlets, each
                    of which can have its own theme, or in the special circumstance that
                    the theme has rules that use empty parent selector
                    <literal>&amp;</literal> to refer to the theme name.
                </para>

                <para>
                    Otherwise, you can safely leave the nested theme selector out as
                    follows:
                </para>

            <programlisting><![CDATA[@import "addons.scss";
@import "mytheme.scss";

@include addons;
@include mytheme;]]></programlisting>

                <para>
                    The actual theme should be defined as follows, as a mixin that
                    includes the base theme.
                </para>

            <programlisting><![CDATA[@import "../reindeer/reindeer.scss";

@mixin mytheme {
  @include reindeer;

  /* An actual theme rule */
  .v-button {
    color: blue;
  }
}
]]></programlisting>
            </section>
        </section>

        <section xml:id="themes.creating.css">
            <title>Plain Old CSS Themes</title>

            <para>
                In addition to Sass themes, you can create plain old CSS themes. CSS theme
                are more restricted than Sass styles - an application can only have one
                CSS theme while you can have multiple Sass themes.
            </para>

            <para>
                A CSS theme is defined in a <filename>styles.css</filename> file in the
                <filename>VAADIN/themes/mytheme</filename> folder. You need to import the
                <filename>legacy-styles.css</filename> of the built-in theme as follows:
            </para>

            <programlisting><![CDATA[@import "../reindeer/legacy-styles.css";

.v-app {
    background: yellow;
}]]></programlisting>
        </section>

        <section xml:id="themes.creating.standard-components" condition="web">
			<title>Styling Standard Components</title>

			<para>
				Each user interface component in Vaadin has a CSS style class that you can
				use to control the appearance of the component. Many components have
				additional sub-elements that also allow styling. You can add
				context-specific stylenames with
				<methodname>addStyleName()</methodname>. Notice that
				<methodname>getStyleName()</methodname> returns only the custom
				stylenames, not the built-in stylenames for the component.
			</para>

			<para>
				Please see the section on each component for a description of its
				styles. Most of the stylenames are determined in the client-side widget of
				each component. The easiest way to find out the styles of the elements is
				to use a HTML inspector such as FireBug. <!-- TODO reference to a Firebug
				section when available -->
			</para>

            <para>
                Some client-side components or component styles can be shared by different
                server-side components. For example, <literal>v-textfield</literal> style
                is used for all text input boxes in components, in addition to
                <classname>TextField</classname>.
            </para>
		</section>

		<section xml:id="themes.creating.builtin">
			<title>Built-in Themes</title>

            <para>
                Vaadin currently includes three built-in themes:
            </para>

            <itemizedlist>
                <listitem><literal>reindeer</literal>, the primary theme in Vaadin 6 and 7</listitem>
                <listitem><literal>runo</literal>, the default theme in IT Mill Toolkit 5</listitem>
                <listitem><literal>chameleon</literal>, an easily customizable alternative theme</listitem>
            </itemizedlist>

            <para>
                In addition, there is the <literal>base</literal> theme, which can not
                be used directly, but is extended by the other built-in themes.
            </para>

			<para>
				The built-in themes are provided in the respective
				<filename>VAADIN/themes/&lt;theme&gt;/styles.scss</filename> stylesheets
				in the <filename>vaadin-themes</filename> JAR. Also the precompiled CSS
				files are included, in case you want to use the themes directly.
			</para>

            <para>
                Various constants related to the built-in themes are defined in the theme
                classes in <package>com.vaadin.ui.themes</package> package. These are
                mostly special style names for specific components.
            </para>

        <programlisting><?pocket-size 65% ?><![CDATA[@Theme("runo")
public class MyUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        ...      
        Panel panel = new Panel("Regular Panel in the Runo Theme");
        panel.addComponent(new Button("Regular Runo Button"));
        
        // A button with the "small" style
        Button smallButton = new Button("Small Runo Button");
        smallButton.addStyleName(Runo.BUTTON_SMALL);

        Panel lightPanel = new Panel("Light Panel");
        lightPanel.addStyleName(Runo.PANEL_LIGHT);
        lightPanel.addComponent(
            new Label("With addStyleName(\"light\")"));
        ...]]></programlisting>

            <para>
                The example with the Runo theme is shown in <xref
                linkend="figure.themes.creating.builtin.runo"/>.
            </para>
					
            <figure xml:id="figure.themes.creating.builtin.runo">
                <title>Runo Theme</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/themes/builtin-runo.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

			<note>
				<title>Serving Built-In Themes Statically</title>

				<para>
					The built-in themes included in the Vaadin library JAR are served
					dynamically from the JAR by the servlet. Serving themes and widget
					sets statically by the web server is more efficient. To do so, you
					need to extract the <filename>VAADIN/</filename> directories from the
					JAR to the web content directory (<filename>WebContent</filename> in
					Eclipse or <filename>src/main/webapp</filename> in Maven projects).
                </para>

                <screen><prompt>$</prompt> <command>cd</command> WebContent</screen>
                <screen><prompt>$</prompt> <command>unzip</command> path-to/vaadin-server-&version.vaadin;.jar 'VAADIN/*'</screen>
                <screen><prompt>$</prompt> <command>unzip</command> path-to/vaadin-themes-&version.vaadin;.jar 'VAADIN/*'</screen>
                <screen><prompt>$</prompt> <command>unzip</command> path-to/vaadin-client-compiled-&version.vaadin;.jar 'VAADIN/*'</screen>

                <para>
                    You can also serve static content from a front-end caching server,
                    which reduces the load of the application server. In portals, you
                    install the themes globally in the portal as described in <xref
                    linkend="portal.liferay.install"/>.
                </para>

                <para>
                    Just make sure to update the static content when you upgrade to a
                    newer version of Vaadin.
				</para>
			</note>

			<para>
				Creation of a default theme for custom GWT widgets is described in <xref
				linkend="gwt.styling"/>.
			</para>
        </section>

		<section xml:id="themes.creating.addon">
			<title>Add-on Themes</title>

            <para>
                You can find more themes as add-ons from the <link
                xlink:href="http://vaadin.com/directory">Vaadin Directory</link>. In
                addition, many component add-ons contain a theme for the components they
                provide.
            </para>

            <para>
                The add-on themes need to be included in the project theme. Vaadin Plugin
                for Eclipse and Maven automatically include them in the
                <filename>addons.scss</filename> file.
            </para>
        </section>
	</section>
    
	<section xml:id="themes.eclipse">
		<title>Creating a Theme in Eclipse</title>

		<para>
			The Eclipse plugin provides a wizard for creating custom themes. Do the
			following steps to create a new theme.
		</para>

		<orderedlist>
			<listitem>
				<para>
					Select
					<menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guimenuitem>Other...</guimenuitem></menuchoice>
					in the main menu or right-click the <guilabel>Project
					Explorer</guilabel> and select
					<menuchoice><guimenu>New</guimenu><guimenuitem>Other...</guimenuitem></menuchoice>. A
					window will open.
				</para>
			</listitem>

			<listitem>
				<para>
					In the <guilabel>Select a wizard</guilabel> step, select the
					<menuchoice><guimenu>Vaadin</guimenu><guimenuitem>Vaadin
					Theme</guimenuitem></menuchoice> wizard.
				</para>

				<screenshot>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/themes/eclipse-theme-new.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-new.png"/>
						</imageobject>
					</mediaobject>
				</screenshot>
				
				<para>
					Click <guibutton>Next</guibutton> to proceed to the next step.
				</para>
			</listitem>

			<listitem>
				<para>
					In the <guilabel>Create a new Vaadin theme</guilabel> step, you have
					the following settings:
				</para>

				<variablelist>
					<varlistentry>
						<term><guilabel>Project</guilabel> (mandatory)</term>
						<listitem>
							<para>
								The project in which the theme should be created.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><guilabel>Theme name</guilabel> (mandatory)</term>
						<listitem>
							<para>
								The theme name is used as the name of the theme folder and
								in a CSS tag (prefixed with
								"<literal>v-theme-</literal>"), so it must be a proper
								identifier. Only latin alphanumerics, underscore, and
								minus sign are allowed.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><guilabel>Modify application classes to use theme</guilabel> (optional)</term>
						<listitem>
							<para>
								The setting allows the wizard to write a code statement
								that enables the theme in the constructor of the selected
								application (UI) class(es). If you need to control the
								theme with dynamic logic, you can leave the setting
								unchecked or change the generated line later.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>

				<screenshot>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/themes/eclipse-theme-settings.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-settings.png"/>
						</imageobject>
					</mediaobject>
				</screenshot>

				<para>
					Click <guibutton>Finish</guibutton> to create the theme.
				</para>

			</listitem>
		</orderedlist>

		<para>
			The wizard creates the theme folder under the
			<filename>WebContent/VAADIN/themes</filename> folder and the actual style
			sheet as <filename>mytheme.scss</filename> and
			<filename>styles.scss</filename> files, as illustrated in <xref
			linkend="figure.eclipse.theme.created"/>.
		</para>

		<figure xml:id="figure.eclipse.theme.created">
			<title>Newly Created Theme</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/themes/eclipse-theme-created-annotated-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-created-annotated-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The created theme extends a built-in base theme with an
			<literal>@import</literal> statement. See the explanation of theme inheritance
			in <xref linkend="themes.creating"/>. Notice that the
			<filename>reindeer</filename> theme is not located in the
			<filename>widgetsets</filename> folder, but in the Vaadin JAR. See <xref
			linkend="themes.creating.builtin"/> for information for serving the built-in
			themes.
		</para>

		<para>
			If you selected a UI class or classes in the <guilabel>Modify application
			classes to use theme</guilabel> in the theme wizard, the wizard will add the
			<literal>@Theme</literal> annotation to the UI class.
        </para>

		<para>
			If you later rename the theme in Eclipse, notice that changing the name of the
			folder will not automatically change the <literal>@Theme</literal>
			annotation. You need to change such references to theme names in the calls
			manually.
		</para>
	</section>

<!--
	<section>
		<title>Theme structure</title>
		<para></para>
	</section>
	<section>
		<title>Custom layouts</title>
		<para></para>
	</section>
	<section>
		<title>Variable handling</title>
		<para></para>
	</section>
	<section>
		<title>AJAX Themes</title>
		<para></para>
	</section>
	<section>
		<title>AJAX Adapter</title>
		<para></para>
	</section>
-->

	<section xml:id="themes.responsive">
		<title>Responsive Themes</title>

        <indexterm xml:id="term.themes.responsive" class="startofrange">
            <primary>Responsive add-on</primary>
        </indexterm>

        <para>
            The Responsive add-on enables size range conditions in CSS selectors, allowing
            conditional CSS rules that respond to size changes in browser window on the
            client-side. <phrase condition="web">See the <link
            xlink:href="https://vaadin.com/blog/-/blogs/3126636">Vaadin Blog article on
            Responsive design</link> for additional information.</phrase>
        </para>

        <para>
            <indexterm><primary>extension</primary></indexterm>

            <classname>Responsive</classname> is a component extension, which you can use
            to extend either a component or the entire UI, which you pass in the
            constructor.
        </para>

        <book-example id="themes.responsive.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[// Have some component with an appropriate style name
Label c = new Label("Here be text");
c.addStyleName("myresponsive");
content.addComponent(c);
        
// Enable Responsive CSS selectors for the component
new Responsive(c);]]></programlisting>

        <para>
            You can now use <literal>width-range</literal> and
            <literal>height-range</literal> conditions in CSS selectors as follows:
        </para>

        <book-example id="themes.responsive.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[/* Basic settings for all sizes */
.myresponsive {
    padding: 5px;
    line-height: 36pt;
}
    
/* Small size */
.myresponsive[width-range~="0-300px"] {
    background: orange;
    font-size: 16pt;
}

/* Medium size */
.myresponsive[width-range~="301px-600px"] {
    background: azure;
    font-size: 24pt;
}

/* Anything bigger */
.myresponsive[width-range~="601px-"] {
    background: palegreen;
    font-size: 36pt;
}]]></programlisting>

        <para>
            You can have overlapping size ranges, in which case all the selectors matching
            the current size are enabled.
        </para>

        <simplesect xml:id="themes.responsive.wrap" condition="web">
            <title>Flexible Wrapping</title>

            <para>
                You can use the <classname>CssLayout</classname> to have automatic
                wrap-around when the components in the layout would go off right side of
                the layout. Components that wrap must, however, have either undefined or
                fixed width, and thereby can not utilize the full area of the
                screen. Using the Responsive add-on, you can have more flexible
                wrap-around that gives the component tiles maximum width.
            </para>

            <para>
                In the following, we have a text and image box, which are laid out
                horizontally with 50-50 sizing if the screen is wide enough, but wrap to a
                vertical layout if the screen is narrow.
            </para>

            <book-example id="themes.responsive.flexwrap" style="float: right"></book-example>
            <programlisting><?pocket-size 75% ?><![CDATA[CssLayout layout = new CssLayout();
layout.setWidth("100%");
layout.addStyleName("flexwrap");
content.addComponent(layout);
        
// Enable Responsive CSS selectors for the layout
new Responsive(layout);

Label title = new Label("Space is big, really big");
title.addStyleName("title");
layout.addComponent(title);

Label description = new Label("This is a " +
    "long description of the image shown " +
    "on the right or below, depending on the " +
    "screen width. The text here could continue long.");
description.addStyleName("itembox");
description.setSizeUndefined();
layout.addComponent(description);
        
Image image = new Image(null, new ThemeResource("img/planets/Earth.jpg"));
image.addStyleName("itembox");
layout.addComponent(image);]]></programlisting>

            <para>
                The SCSS could be as follows:
            </para>

            <book-example id="themes.responsive.flexwrap" style="float: right"></book-example>
            <programlisting><?pocket-size 75% ?><![CDATA[/* Various general settings */
.flexwrap {
    background: black;
    color: white;

    .title {
        font-weight: bold;
        font-size: 20px;
        line-height: 30px;
        padding: 5px;
    }
    
    .itembox {
        white-space: normal;
        vertical-align: top;
    }
    
    .itembox.v-label {padding: 5px}
}
    
.flexwrap[width-range~="0-499px"] {
    .itembox {width: 100%}
}
    
.flexwrap[width-range~="500px-"] {
    .itembox {width: 50%}
}]]></programlisting>
            
            <para>
                The layout in the wide mode is shown in <xref
                linkend="figure.theme.responsive.flexwrap"/>.
            </para>

            <figure xml:id="figure.theme.responsive.flexwrap">
                <title>Flexible Wrapping</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/themes/addon-responsive-flexwrap.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You could also play with the <literal>display: block</literal> vs
                <literal>display: inline-block</literal> properties.
            </para>

            <para>
                Notice that while the Responsive add-on makes it possible to do various
                CSS trickery with component sizes, the normal rules for component and
                layout sizes apply, as described in <xref linkend="layout.settings.size"/>
                and elsewhere, and you should always check the size behaviour of the
                components. In the above example, we set the label to have undefined
                width, which disables word wrap, so we had to re-enable it.
            </para>
        </simplesect>

        <simplesect xml:id="themes.responsive.display" condition="web">
            <title>Toggling the Display Property</title>

            <para>
                <indexterm><primary>display (CSS property)</primary></indexterm>

                The <literal>display</literal> property allows especially powerful ways to
                offer radically different UIs for different screen sizes by enabling and
                disabling UI elements as needed. For example, you could disable some parts of
                the UI when the space gets too small, but bring forth navigation buttons that,
                when clicked, add component styles to switch to the hidden parts.
            </para>

            <para>
                In the following, we simply show alternative components based on screen
                width:
            </para>

            <book-example id="themes.responsive.display" style="float: right"></book-example>
            <programlisting><?pocket-size 75% ?><![CDATA[CssLayout layout = new CssLayout();
layout.setWidth("100%");
layout.addStyleName("toggledisplay");
content.addComponent(layout);
        
// Enable Responsive CSS selectors for the layout
new Responsive(layout);

Label enoughspace =
    new Label("This space is big, mindbogglingly big");
enoughspace.addStyleName("enoughspace");
layout.addComponent(enoughspace);
        
Label notenoughspace = new Label("Quite small space");
notenoughspace.addStyleName("notenoughspace");
layout.addComponent(notenoughspace);]]></programlisting>

            <para>
                The SCSS could be as follows:
            </para>

            <book-example id="themes.responsive.display" style="float: right"></book-example>
            <programlisting><?pocket-size 75% ?><![CDATA[/* Common settings */
.toggledisplay {
    .enoughspace, .notenoughspace {
        color: white;
        padding: 5px;
    }
    
    .notenoughspace { /* Really small */
        background: red;
        font-weight: normal;
        font-size: 10px;
        line-height: 15px;
    }

    .enoughspace { /* Really big */
        background: darkgreen;
        font-weight: bold;
        font-size: 20px;
        line-height: 30px;
    }
}
    
/* Quite little space */
.toggledisplay[width-range~="0-499px"] {
    .enoughspace    {display: none}
}
    
/* Plenty of space */
.toggledisplay[width-range~="500px-"] {
    .notenoughspace {display: none}
}]]></programlisting>
        </simplesect>

        <simplesect xml:id="themes.responsive.installation">
            <title>Installing the Responsive Add-on</title>

            <para>
                The add-on is currently available from Vaadin Directory at <link
                xlink:href="https://vaadin.com/addon/vaadin-responsive">https://vaadin.com/addon/vaadin-responsive</link>,
                using either download or as Maven/Ivy dependency. Addon installation is
                described in <xref linkend="addons"/>.
            </para>
        </simplesect>

        <simplesect xml:id="themes.responsive.demos">
            <title>Responsive Demos</title>

            <para>
                <indexterm><primary>Parking demo</primary></indexterm>
                <indexterm><primary>TouchKit</primary><secondary>Parking demo</secondary></indexterm>

                The Responsive add-on page includes a link to a demo. In addition, the
                Parking demo for TouchKit, mentioned in <xref linkend="mobile"/>, uses a
                responsive theme to adapt to mobile devices with different screen sizes
                and when the screen orientation changes.
            </para>
        </simplesect>

        <indexterm startref="term.themes.responsive" class="endofrange"/>
    </section>

    <indexterm startref="term.themes" class="endofrange"/>
    <indexterm startref="term.themes-css" class="endofrange"/>
</chapter>

	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

